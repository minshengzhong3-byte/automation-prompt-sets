# æ¼æ´åˆ†æä¸æŒ–æ˜æŒ‡å—

## ğŸ” æ¼æ´åˆ†ææ¡†æ¶

### æ¼æ´åˆ†ç±»ä½“ç³»
```prompt
æ¼æ´ç±»å‹åˆ†ç±»ï¼š
1. å†…å­˜å®‰å…¨æ¼æ´ï¼šç¼“å†²åŒºæº¢å‡ºã€UAFã€æ•´æ•°æº¢å‡º
2. é€»è¾‘æ¼æ´ï¼šè®¤è¯ç»•è¿‡ã€æƒé™æå‡ã€ä¸šåŠ¡é€»è¾‘ç¼ºé™·
3. è¾“å…¥éªŒè¯æ¼æ´ï¼šSQLæ³¨å…¥ã€XSSã€å‘½ä»¤æ³¨å…¥
4. åŠ å¯†æ¼æ´ï¼šå¼±åŠ å¯†ã€å¯†é’¥æ³„éœ²ã€éšæœºæ•°é¢„æµ‹
5. é…ç½®æ¼æ´ï¼šé»˜è®¤é…ç½®ã€æƒé™é…ç½®é”™è¯¯
6. ç½‘ç»œåè®®æ¼æ´ï¼šåè®®è®¾è®¡ç¼ºé™·ã€å®ç°é”™è¯¯
```

### æ¼æ´æŒ–æ˜æ–¹æ³•è®º
```prompt
æ¼æ´æŒ–æ˜æŠ€æœ¯ï¼š
1. é™æ€åˆ†æï¼šæºä»£ç å®¡æŸ¥ã€æ¨¡å¼åŒ¹é…
2. åŠ¨æ€åˆ†æï¼šæ¨¡ç³Šæµ‹è¯•ã€ç¬¦å·æ‰§è¡Œ
3. æ··åˆåˆ†æï¼šç»“åˆé™æ€å’ŒåŠ¨æ€æŠ€æœ¯
4. äººå·¥å®¡è®¡ï¼šä»£ç èµ°æŸ¥ã€é€»è¾‘åˆ†æ
5. è‡ªåŠ¨åŒ–å·¥å…·ï¼šæ¼æ´æ‰«æå™¨ã€åˆ†ææ¡†æ¶
6. å¨èƒå»ºæ¨¡ï¼šæ”»å‡»é¢åˆ†æã€é£é™©è¯„ä¼°
```

## ğŸ› ï¸ æ¼æ´æŒ–æ˜å·¥å…·é“¾

### é™æ€åˆ†æå·¥å…·
```prompt
é™æ€åˆ†æå·¥å…·é›†ï¼š
1. å•†ä¸šå·¥å…·ï¼šCoverityã€Fortifyã€Checkmarx
2. å¼€æºå·¥å…·ï¼šFlawfinderã€RATSã€Cppcheck
3. äºŒè¿›åˆ¶åˆ†æï¼šIDA Proã€Ghidraã€Binary Ninja
4. ç¬¦å·æ‰§è¡Œï¼šAngrã€KLEEã€S2E
5. æ¨¡ç³Šæµ‹è¯•ï¼šAFLã€libFuzzerã€Peach
6. ç½‘ç»œåˆ†æï¼šWiresharkã€Burp Suiteã€Fiddler
```

### è‡ªåŠ¨åŒ–æ¼æ´æŒ–æ˜
```python
# æ¼æ´æŒ–æ˜æ¡†æ¶
import struct
import socket
import threading
from typing import List, Dict, Any
import subprocess

class VulnerabilityAnalyzer:
    def __init__(self, target_binary: str):
        self.target_binary = target_binary
        self.vulnerabilities = []
        self.analysis_results = {}
        
    def static_analysis(self) -> Dict[str, Any]:
        """é™æ€æ¼æ´åˆ†æ"""
        findings = {
            "buffer_overflows": [],
            "format_strings": [],
            "integer_overflows": [],
            "command_injections": [],
            "sql_injections": []
        }
        
        # 1. ç¼“å†²åŒºæº¢å‡ºæ£€æµ‹
        buffer_patterns = [
            "strcpy", "strcat", "sprintf", "gets", "scanf"
        ]
        
        # 2. æ ¼å¼åŒ–å­—ç¬¦ä¸²æ£€æµ‹
        format_patterns = [
            "printf", "fprintf", "sprintf", "snprintf"
        ]
        
        # 3. æ•´æ•°æº¢å‡ºæ£€æµ‹
        integer_patterns = [
            "malloc", "calloc", "realloc", "memcpy"
        ]
        
        # ä½¿ç”¨radare2è¿›è¡Œé™æ€åˆ†æ
        try:
            cmd = ["rabin2", "-z", self.target_binary]
            result = subprocess.run(cmd, capture_output=True, text=True)
            strings = result.stdout.split('\n')
            
            for string in strings:
                for pattern in buffer_patterns:
                    if pattern in string.lower():
                        findings["buffer_overflows"].append({
                            "function": pattern,
                            "string": string,
                            "severity": "high"
                        })
                        
        except Exception as e:
            findings["error"] = str(e)
            
        return findings
        
    def dynamic_analysis(self) -> Dict[str, Any]:
        """åŠ¨æ€æ¼æ´åˆ†æ"""
        findings = {
            "crash_analysis": [],
            "memory_corruption": [],
            "input_validation": [],
            "race_conditions": []
        }
        
        # 1. æ¨¡ç³Šæµ‹è¯•
        fuzz_results = self.run_fuzzing()
        findings["crash_analysis"].extend(fuzz_results)
        
        # 2. å†…å­˜æ£€æµ‹
        memory_results = self.run_memory_analysis()
        findings["memory_corruption"].extend(memory_results)
        
        return findings
        
    def run_fuzzing(self) -> List[Dict[str, Any]]:
        """æ‰§è¡Œæ¨¡ç³Šæµ‹è¯•"""
        crashes = []
        
        # AFLæ¨¡ç³Šæµ‹è¯•ç¤ºä¾‹
        try:
            cmd = ["afl-fuzz", "-i", "input", "-o", "output", "--", self.target_binary]
            # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è¿è¡Œå®Œæ•´çš„æ¨¡ç³Šæµ‹è¯•
            crashes.append({
                "type": "buffer_overflow",
                "input": "A" * 1000,
                "crash_address": "0x41414141",
                "severity": "high"
            })
            
        except Exception as e:
            crashes.append({
                "error": str(e),
                "type": "fuzzing_failed"
            })
            
        return crashes
        
    def run_memory_analysis(self) -> List[Dict[str, Any]]:
        """å†…å­˜å®‰å…¨åˆ†æ"""
        memory_issues = []
        
        # Valgrindå†…å­˜æ£€æµ‹
        try:
            cmd = ["valgrind", "--leak-check=full", self.target_binary]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if "invalid read" in result.stderr:
                memory_issues.append({
                    "type": "invalid_memory_access",
                    "details": "Detected invalid memory read",
                    "severity": "medium"
                })
                
            if "definitely lost" in result.stderr:
                memory_issues.append({
                    "type": "memory_leak",
                    "details": "Memory leak detected",
                    "severity": "low"
                })
                
        except Exception as e:
            memory_issues.append({
                "error": str(e),
                "type": "memory_analysis_failed"
            })
            
        return memory_issues

# ç½‘ç»œåè®®æ¼æ´åˆ†æ
class ProtocolVulnerabilityAnalyzer:
    def __init__(self, protocol_spec: Dict[str, Any]):
        self.protocol_spec = protocol_spec
        self.protocol_vulnerabilities = []
        
    def analyze_protocol_design(self) -> List[Dict[str, Any]]:
        """åˆ†æåè®®è®¾è®¡æ¼æ´"""
        vulnerabilities = []
        
        # 1. è®¤è¯æœºåˆ¶åˆ†æ
        if "authentication" not in self.protocol_spec:
            vulnerabilities.append({
                "type": "missing_authentication",
                "description": "åè®®ç¼ºå°‘è®¤è¯æœºåˆ¶",
                "severity": "high",
                "impact": "æœªæˆæƒè®¿é—®"
            })
            
        # 2. åŠ å¯†æœºåˆ¶åˆ†æ
        if "encryption" not in self.protocol_spec:
            vulnerabilities.append({
                "type": "missing_encryption",
                "description": "åè®®ç¼ºå°‘åŠ å¯†ä¿æŠ¤",
                "severity": "high",
                "impact": "æ•°æ®æ³„éœ²"
            })
            
        # 3. è¾“å…¥éªŒè¯åˆ†æ
        if "input_validation" not in self.protocol_spec:
            vulnerabilities.append({
                "type": "missing_input_validation",
                "description": "åè®®ç¼ºå°‘è¾“å…¥éªŒè¯",
                "severity": "medium",
                "impact": "æ³¨å…¥æ”»å‡»"
            })
            
        return vulnerabilities
        
    def analyze_implementation(self) -> List[Dict[str, Any]]:
        """åˆ†æå®ç°æ¼æ´"""
        vulnerabilities = []
        
        # 1. ç¼“å†²åŒºæº¢å‡º
        if self.check_buffer_overflow():
            vulnerabilities.append({
                "type": "buffer_overflow",
                "description": "åè®®å¤„ç†å­˜åœ¨ç¼“å†²åŒºæº¢å‡º",
                "severity": "high",
                "impact": "è¿œç¨‹ä»£ç æ‰§è¡Œ"
            })
            
        # 2. æ•´æ•°æº¢å‡º
        if self.check_integer_overflow():
            vulnerabilities.append({
                "type": "integer_overflow",
                "description": "åè®®å¤„ç†å­˜åœ¨æ•´æ•°æº¢å‡º",
                "severity": "medium",
                "impact": "æ‹’ç»æœåŠ¡"
            })
            
        return vulnerabilities
        
    def check_buffer_overflow(self) -> bool:
        """æ£€æŸ¥ç¼“å†²åŒºæº¢å‡º"""
        # ç®€åŒ–çš„æ£€æŸ¥é€»è¾‘
        return True  # å®é™…åº”è¯¥è¿›è¡Œè¯¦ç»†åˆ†æ
        
    def check_integer_overflow(self) -> bool:
        """æ£€æŸ¥æ•´æ•°æº¢å‡º"""
        # ç®€åŒ–çš„æ£€æŸ¥é€»è¾‘
        return False  # å®é™…åº”è¯¥è¿›è¡Œè¯¦ç»†åˆ†æ

# Webåº”ç”¨æ¼æ´åˆ†æ
class WebVulnerabilityAnalyzer:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.web_vulnerabilities = []
        
    def scan_sql_injection(self) -> List[Dict[str, Any]]:
        """SQLæ³¨å…¥æ¼æ´æ‰«æ"""
        sql_payloads = [
            "' OR 1=1--",
            "' UNION SELECT null--",
            "'; DROP TABLE users;--",
            "' OR 'a'='a"
        ]
        
        findings = []
        
        for payload in sql_payloads:
            # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥å‘é€HTTPè¯·æ±‚
            if self.test_sql_payload(payload):
                findings.append({
                    "type": "sql_injection",
                    "payload": payload,
                    "endpoint": self.target_url,
                    "severity": "high"
                })
                
        return findings
        
    def scan_xss(self) -> List[Dict[str, Any]]:
        """XSSæ¼æ´æ‰«æ"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>"
        ]
        
        findings = []
        
        for payload in xss_payloads:
            if self.test_xss_payload(payload):
                findings.append({
                    "type": "cross_site_scripting",
                    "payload": payload,
                    "endpoint": self.target_url,
                    "severity": "medium"
                })
                
        return findings
        
    def test_sql_payload(self, payload: str) -> bool:
        """æµ‹è¯•SQLæ³¨å…¥payload"""
        # ç®€åŒ–çš„æµ‹è¯•é€»è¾‘
        return False  # å®é™…åº”è¯¥è¿›è¡ŒHTTPè¯·æ±‚æµ‹è¯•
        
    def test_xss_payload(self, payload: str) -> bool:
        """æµ‹è¯•XSS payload"""
        # ç®€åŒ–çš„æµ‹è¯•é€»è¾‘
        return False  # å®é™…åº”è¯¥è¿›è¡ŒHTTPè¯·æ±‚æµ‹è¯•

# æ¼æ´åˆ©ç”¨æ¡†æ¶
class ExploitFramework:
    def __init__(self):
        self.exploits = {}
        
    def generate_exploit(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆæ¼æ´åˆ©ç”¨ä»£ç """
        exploit = {
            "target": vulnerability.get("target", ""),
            "vulnerability_type": vulnerability.get("type", ""),
            "payload": "",
            "exploit_code": "",
            "success_conditions": []
        }
        
        if vulnerability["type"] == "buffer_overflow":
            exploit["payload"] = self.generate_buffer_overflow_payload(vulnerability)
            exploit["exploit_code"] = self.generate_buffer_overflow_exploit(vulnerability)
            
        elif vulnerability["type"] == "sql_injection":
            exploit["payload"] = self.generate_sql_injection_payload(vulnerability)
            exploit["exploit_code"] = self.generate_sql_injection_exploit(vulnerability)
            
        return exploit
        
    def generate_buffer_overflow_payload(self, vuln: Dict[str, Any]) -> str:
        """ç”Ÿæˆç¼“å†²åŒºæº¢å‡ºpayload"""
        return "A" * 1000  # ç®€åŒ–çš„payload
        
    def generate_buffer_overflow_exploit(self, vuln: Dict[str, Any]) -> str:
        """ç”Ÿæˆç¼“å†²åŒºæº¢å‡ºåˆ©ç”¨ä»£ç """
        return """
#!/usr/bin/env python3
import struct
import socket

def exploit_buffer_overflow(target_ip, target_port):
    # ç¼“å†²åŒºæº¢å‡ºåˆ©ç”¨ä»£ç 
    payload = b"A" * 1000
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    s.send(payload)
    s.close()

if __name__ == "__main__":
    exploit_buffer_overflow("127.0.0.1", 9999)
"""
        
    def generate_sql_injection_payload(self, vuln: Dict[str, Any]) -> str:
        """ç”ŸæˆSQLæ³¨å…¥payload"""
        return "' OR 1=1--"
        
    def generate_sql_injection_exploit(self, vuln: Dict[str, Any]) -> str:
        """ç”ŸæˆSQLæ³¨å…¥åˆ©ç”¨ä»£ç """
        return """
#!/usr/bin/env python3
import requests

def exploit_sql_injection(target_url):
    # SQLæ³¨å…¥åˆ©ç”¨ä»£ç 
    payload = "' OR 1=1--"
    params = {"id": payload}
    response = requests.get(target_url, params=params)
    return response.text

if __name__ == "__main__":
    print(exploit_sql_injection("http://target.com/vulnerable.php"))
"""
```

## ğŸ¯ æ¼æ´æŒ–æ˜ç­–ç•¥

### æ”»å‡»é¢åˆ†æ
```prompt
æ”»å‡»é¢è¯†åˆ«ï¼š
1. è¾“å…¥æ¥å£ï¼šç”¨æˆ·è¾“å…¥ã€æ–‡ä»¶ä¸Šä¼ ã€ç½‘ç»œæ•°æ®
2. è¾“å‡ºæ¥å£ï¼šé”™è¯¯ä¿¡æ¯ã€æ—¥å¿—è®°å½•ã€å“åº”æ•°æ®
3. è®¤è¯æœºåˆ¶ï¼šç™»å½•ç³»ç»Ÿã€ä¼šè¯ç®¡ç†ã€æƒé™æ§åˆ¶
4. æ•°æ®å­˜å‚¨ï¼šæ•°æ®åº“ã€æ–‡ä»¶ç³»ç»Ÿã€ç¼“å­˜ç³»ç»Ÿ
5. ç½‘ç»œé€šä¿¡ï¼šåè®®å®ç°ã€åŠ å¯†ä¼ è¾“ã€APIæ¥å£
6. ç¬¬ä¸‰æ–¹ç»„ä»¶ï¼šåº“ä¾èµ–ã€æ¡†æ¶æ¼æ´ã€æœåŠ¡é…ç½®
```

### æ¼æ´åˆ©ç”¨å¼€å‘
```prompt
åˆ©ç”¨å¼€å‘æµç¨‹ï¼š
1. æ¼æ´ç¡®è®¤ï¼šéªŒè¯æ¼æ´å­˜åœ¨æ€§å’Œå¯åˆ©ç”¨æ€§
2. ä¿¡æ¯æ”¶é›†ï¼šæ”¶é›†ç›®æ ‡ç¯å¢ƒå’Œé…ç½®ä¿¡æ¯
3. åˆ©ç”¨å¼€å‘ï¼šç¼–å†™æ¼æ´åˆ©ç”¨ä»£ç 
4. æµ‹è¯•éªŒè¯ï¼šåœ¨å—æ§ç¯å¢ƒæµ‹è¯•åˆ©ç”¨ä»£ç 
5. ä¼˜åŒ–æ”¹è¿›ï¼šæé«˜åˆ©ç”¨æˆåŠŸç‡å’Œç¨³å®šæ€§
6. æ–‡æ¡£è®°å½•ï¼šè®°å½•åˆ©ç”¨æ–¹æ³•å’Œæ³¨æ„äº‹é¡¹
```

## ğŸ“Š æ¼æ´è¯„ä¼°ä¸æŠ¥å‘Š

### æ¼æ´è¯„åˆ†ç³»ç»Ÿ
```prompt
æ¼æ´è¯„ä¼°æ ‡å‡†ï¼š
1. CVSSè¯„åˆ†ï¼šé€šç”¨æ¼æ´è¯„åˆ†ç³»ç»Ÿ
2. ä¸šåŠ¡å½±å“ï¼šå¯¹ä¸šåŠ¡ç³»ç»Ÿçš„å½±å“ç¨‹åº¦
3. åˆ©ç”¨éš¾åº¦ï¼šæ”»å‡»è€…åˆ©ç”¨çš„æŠ€æœ¯é—¨æ§›
4. å½±å“èŒƒå›´ï¼šå—å½±å“çš„ç³»ç»ŸèŒƒå›´
5. ä¿®å¤éš¾åº¦ï¼šä¿®å¤æ¼æ´çš„å¤æ‚ç¨‹åº¦
6. æ—¶é—´å› ç´ ï¼šæ¼æ´å­˜åœ¨æ—¶é—´å’Œä¿®å¤æ—¶é—´
```

### æ¼æ´æŠ¥å‘Šæ¨¡æ¿
```markdown
# æ¼æ´åˆ†ææŠ¥å‘Š

## æ¼æ´åŸºæœ¬ä¿¡æ¯
- **æ¼æ´ç¼–å·**: VULN-2024-XXXX
- **å‘ç°æ—¶é—´**: 2024-XX-XX
- **æ¼æ´ç±»å‹**: [ç¼“å†²åŒºæº¢å‡º/SQLæ³¨å…¥/XSSç­‰]
- **ä¸¥é‡ç¨‹åº¦**: [Critical/High/Medium/Low]
- **CVSSè¯„åˆ†**: X.X

## æ¼æ´æè¿°
### æ¼æ´æ¦‚è¿°
[æ¼æ´çš„åŸºæœ¬æè¿°å’Œå½±å“]

### æŠ€æœ¯ç»†èŠ‚
[æ¼æ´çš„æŠ€æœ¯åŸç†å’Œè§¦å‘æ¡ä»¶]

### å½±å“èŒƒå›´
[å—å½±å“çš„ç³»ç»Ÿã€ç»„ä»¶æˆ–ç”¨æˆ·]

## æ¼æ´éªŒè¯
### å¤ç°æ­¥éª¤
1. [è¯¦ç»†çš„å¤ç°æ­¥éª¤]
2. [å¿…è¦çš„è¾“å…¥æ•°æ®]
3. [é¢„æœŸçš„ç»“æœ]

### éªŒè¯ç¯å¢ƒ
- æ“ä½œç³»ç»Ÿ: [å…·ä½“ç‰ˆæœ¬]
- è½¯ä»¶ç‰ˆæœ¬: [å…·ä½“ç‰ˆæœ¬]
- é…ç½®ä¿¡æ¯: [ç›¸å…³é…ç½®]

## æ¼æ´åˆ©ç”¨
### åˆ©ç”¨æ¡ä»¶
[æˆåŠŸåˆ©ç”¨æ¼æ´æ‰€éœ€çš„æ¡ä»¶]

### åˆ©ç”¨ä»£ç 
```python
# æ¼æ´åˆ©ç”¨ä»£ç ç¤ºä¾‹
[å…·ä½“çš„åˆ©ç”¨ä»£ç ]
```

### åˆ©ç”¨æ•ˆæœ
[æˆåŠŸåˆ©ç”¨åçš„ç»“æœå’Œå½±å“]

## ä¿®å¤å»ºè®®
### çŸ­æœŸæªæ–½
[å¯ä»¥ç«‹å³é‡‡å–çš„ç¼“è§£æªæ–½]

### é•¿æœŸæ–¹æ¡ˆ
[æ ¹æœ¬æ€§çš„ä¿®å¤æ–¹æ¡ˆ]

### éªŒè¯æ–¹æ³•
[ä¿®å¤åçš„éªŒè¯æ–¹æ³•]

## æ—¶é—´çº¿
- **å‘ç°æ—¶é—´**: 2024-XX-XX
- **æŠ¥å‘Šæ—¶é—´**: 2024-XX-XX
- **ä¿®å¤æ—¶é—´**: 2024-XX-XX
- **éªŒè¯æ—¶é—´**: 2024-XX-XX

## å‚è€ƒèµ„æ–™
- [ç›¸å…³çš„æŠ€æœ¯æ–‡æ¡£]
- [ç±»ä¼¼æ¼æ´çš„æ¡ˆä¾‹]
- [ä¿®å¤æ–¹æ¡ˆçš„å‚è€ƒ]
```

## ğŸ”„ æŒç»­æ¼æ´ç®¡ç†

### æ¼æ´ç”Ÿå‘½å‘¨æœŸ
```prompt
æ¼æ´ç®¡ç†æµç¨‹ï¼š
1. å‘ç°é˜¶æ®µï¼šæ¼æ´è¯†åˆ«å’Œåˆæ­¥åˆ†æ
2. è¯„ä¼°é˜¶æ®µï¼šå½±å“è¯„ä¼°å’Œä¼˜å…ˆçº§æ’åº
3. ä¿®å¤é˜¶æ®µï¼šåˆ¶å®šå’Œå®æ–½ä¿®å¤æ–¹æ¡ˆ
4. éªŒè¯é˜¶æ®µï¼šéªŒè¯ä¿®å¤æ•ˆæœå’Œå®‰å…¨æ€§
5. ç›‘æ§é˜¶æ®µï¼šæŒç»­ç›‘æ§å’Œåç»­æ”¹è¿›
6. æ€»ç»“é˜¶æ®µï¼šç»éªŒæ€»ç»“å’ŒçŸ¥è¯†åˆ†äº«
```

### è‡ªåŠ¨åŒ–æ¼æ´ç›‘æ§
```python
# è‡ªåŠ¨åŒ–æ¼æ´ç›‘æ§ç³»ç»Ÿ
import time
import requests
from datetime import datetime

class VulnerabilityMonitor:
    def __init__(self):
        self.monitored_targets = []
        self.alert_thresholds = {}
        
    def add_target(self, target_info: Dict[str, Any]):
        """æ·»åŠ ç›‘æ§ç›®æ ‡"""
        self.monitored_targets.append({
            "target": target_info["target"],
            "type": target_info["type"],
            "last_scan": None,
            "vulnerabilities": []
        })
        
    def scan_target(self, target: Dict[str, Any]) -> List[Dict[str, Any]]:
        """æ‰«æç‰¹å®šç›®æ ‡"""
        # è¿™é‡Œå®ç°å…·ä½“çš„æ‰«æé€»è¾‘
        new_vulnerabilities = []
        
        # æ¨¡æ‹Ÿæ‰«æç»“æœ
        new_vulnerabilities.append({
            "target": target["target"],
            "type": "new_vulnerability",
            "severity": "medium",
            "discovered_at": datetime.now().isoformat()
        })
        
        return new_vulnerabilities
        
    def generate_alert(self, vulnerabilities: List[Dict[str, Any]]):
        """ç”Ÿæˆå®‰å…¨è­¦æŠ¥"""
        for vuln in vulnerabilities:
            if vuln["severity"] == "high":
                print(f"ğŸš¨ HIGH SEVERITY: {vuln['type']} found in {vuln['target']}")
            elif vuln["severity"] == "medium":
                print(f"âš ï¸ MEDIUM SEVERITY: {vuln['type']} found in {vuln['target']}")
```

---
**åˆ†æç±»å‹:** æ¼æ´åˆ†æä¸æŒ–æ˜
**ç‰ˆæœ¬:** 1.0.0
**ç»§æ‰¿:** é€†å‘å·¥ç¨‹æ¡†æ¶